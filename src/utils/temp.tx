"use client"

import type React from "react"
import { useState, useRef, useEffect, useCallback, useMemo } from "react"
import { ArrowLeft, MoreVertical, Search, Phone, VideoIcon } from "lucide-react"
import { Button } from "@/components/ui/button"
import { Avatar } from "@/components/ui/avatar"
import { Input } from "@/components/ui/input"
import { Badge } from "@/components/ui/badge"
import { useMobile } from "@/hooks/use-mobile"
import MessageBubble from "@/components/chat/message-bubble"
import { getAllUserForSpecificChat, getChatMessages, sendChatMessage } from "@/actions/chat"
import { Chat } from "@/interface/interface"
import { useAuth } from "@/providers/auth-provider"

interface ChatWindowProps {
  chatId: string | null
  onBackClick: () => void
  onProfileClick: () => void
  isChatLoading: boolean
  userChats: Chat[]
}

export default function ChatWindow({ 
  chatId, 
  onBackClick, 
  onProfileClick,
  isChatLoading,
  userChats
}: ChatWindowProps) {
  const [newMessage, setNewMessage] = useState("")
  const [chatMessages, setChatMessages] = useState<any[]>([])
  const [isMessagesLoading, setIsMessagesLoading] = useState(false)
  const messagesEndRef = useRef<HTMLDivElement>(null)
  const isMobile = useMobile()
  const { user } = useAuth()
  
  // Find the selected chat from userChats
  const selectedChat = useMemo(() => {
    return userChats.find(chat => chat.id === chatId) || null
  }, [chatId, userChats])

  // Group messages by date - memoized to prevent recalculation on every render
  const messagesByDate = useMemo(() => {
    const groupedMessages: Record<string, any[]> = {}
    
    // Ensure chatMessages is an array before using forEach
    if (Array.isArray(chatMessages)) {
      chatMessages.forEach((message) => {
        if (message && message.sent_at) {
          const date = new Date(message.sent_at).toLocaleDateString()
          if (!groupedMessages[date]) {
            groupedMessages[date] = []
          }
          groupedMessages[date].push(message)
        }
      })
    }
    
    return groupedMessages
  }, [chatMessages])

  
  


  const handleSendMessage = useCallback(async (e: React.FormEvent) => {
    e.preventDefault()
    if (!newMessage.trim() || !chatId) return

    try {
      // Send message to server
      await sendChatMessage(chatId, newMessage)
      
      // Refresh messages
      const messages = await getChatMessages(chatId)
      setChatMessages(Array.isArray(messages) ? messages : [])
      
      // Clear the input
      setNewMessage("")
    } catch (error) {
      console.error("Error sending message:", error)
    }
  }, [newMessage, chatId])


  // Fetch messages when chatId changes
  useEffect(() => {
    const fetchMessages = async () => {
      if (!chatId) return
      
      setIsMessagesLoading(true)
      try {
        const messages = await getChatMessages(chatId)
        setChatMessages(Array.isArray(messages) ? messages : [])
      } catch (error) {
        console.error("Error fetching messages:", error)
        setChatMessages([]) 
      } finally {
        setIsMessagesLoading(false)
      }
    }
    
    fetchMessages()
  }, [chatId])



  
  // Scroll to bottom when messages change
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" })
  }, [chatMessages])

  if (isChatLoading || isMessagesLoading) {
    return (
      <div className="flex items-center justify-center h-full">
        <div className="animate-spin h-8 w-8 border-4 border-primary border-t-transparent rounded-full"></div>
      </div>
    )
  }

  if (!selectedChat) {
    return (
      <div className="flex items-center justify-center h-full bg-muted/20">
        <div className="text-center">
          <h2 className="text-xl font-semibold mb-2">Chat App</h2>
          <p className="text-muted-foreground">Select a chat to start messaging</p>
        </div>
      </div>
    )
  }

  return (
    <div className="flex flex-col h-full">
      {/* Chat Header */}
      <div className="flex items-center p-2 border-b bg-sidebar">
        {isMobile && (
          <Button variant="ghost" size="icon" className="mr-1" onClick={onBackClick}>
            <ArrowLeft className="h-5 w-5" />
          </Button>
        )}

        <div className="flex items-center flex-1 cursor-pointer" onClick={onProfileClick}>
          <Avatar className="h-10 w-10 mr-3">
            <img src={selectedChat.avatar || "/placeholder.svg?height=40&width=40"} alt={selectedChat.title} />
          </Avatar>

          <div>
            <h3 className="font-medium text-sm">{selectedChat.title}</h3>
            <p className="text-xs text-muted-foreground">
              {selectedChat.isGroup ? "Group Â· " : ""}
              {selectedChat.status || "online"}
            </p>
          </div>
        </div>

        <div className="flex items-center gap-1">
          <Button variant="ghost" size="icon" className="rounded-full">
            <VideoIcon className="h-5 w-5" />
          </Button>
          <Button variant="ghost" size="icon" className="rounded-full">
            <Phone className="h-5 w-5" />
          </Button>
          <Button variant="ghost" size="icon" className="rounded-full">
            <Search className="h-5 w-5" />
          </Button>
          <Button variant="ghost" size="icon" className="rounded-full">
            <MoreVertical className="h-5 w-5" />
          </Button>
        </div>
      </div>

      {/* Messages */}
      <div
        className="flex-1 overflow-y-auto p-4 space-y-4"
        style={{
          backgroundImage: "url('/placeholder.svg?height=500&width=500')",
          backgroundSize: "30%",
          backgroundRepeat: "repeat",
        }}
      >
        {Object.entries(messagesByDate).map(([date, dateMessages]) => (
          <div key={date} className="space-y-2">
            <div className="flex justify-center">
              <Badge variant="outline" className="bg-background/80 text-xs font-normal">
                {date}
              </Badge>
            </div>

            {dateMessages.map((message) => {
              // Check if the current user is the sender
              const isCurrentUserSender = user?.id === message.sender_id;
              
              return (
                <MessageBubble 
                  key={message.id} 
                  message={{
                    id: message.id,
                    senderId: message.sender_id,
                    senderName: message.sender.name,
                    senderAvatar: message.sender.avatar_url,
                    content: message.content,
                    time: new Date(message.sent_at).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}),
                    date: new Date(message.sent_at).toLocaleDateString(),
                    label: message.type !== "text" ? message.type : undefined
                  }} 
                  isOwn={isCurrentUserSender} 
                />
              );
            })}
          </div>
        ))}
        {(!chatMessages || chatMessages.length === 0) && (
          <div className="flex justify-center items-center h-full">
            <p className="text-muted-foreground">No messages yet</p>
          </div>
        )}
        <div ref={messagesEndRef} />
      </div>

      {/* Message Input */}
      <div className="p-2 border-t bg-sidebar">
        <form onSubmit={handleSendMessage} className="flex items-center gap-2">
          <Button type="button" variant="ghost" size="icon" className="rounded-full">
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="24"
              height="24"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              strokeWidth="2"
              strokeLinecap="round"
              strokeLinejoin="round"
              className="lucide lucide-smile"
            >
              <circle cx="12" cy="12" r="10" />
              <path d="M8 14s1.5 2 4 2 4-2 4-2" />
              <line x1="9" x2="9.01" y1="9" y2="9" />
              <line x1="15" x2="15.01" y1="9" y2="9" />
            </svg>
          </Button>
          <Button type="button" variant="ghost" size="icon" className="rounded-full">
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="24"
              height="24"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              strokeWidth="2"
              strokeLinecap="round"
              strokeLinejoin="round"
              className="lucide lucide-paperclip"
            >
              <path d="m21.44 11.05-9.19 9.19a6 6 0 0 1-8.49-8.49l8.57-8.57A4 4 0 1 1 18 8.84l-8.59 8.57a2 2 0 0 1-2.83-2.83l8.49-8.48" />
            </svg>
          </Button>

          <Input
            value={newMessage}
            onChange={(e) => setNewMessage(e.target.value)}
            placeholder="Type a message"
            className="rounded-full bg-background"
          />

          <Button type="submit" variant="ghost" size="icon" className="rounded-full">
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="24"
              height="24"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              strokeWidth="2"
              strokeLinecap="round"
              strokeLinejoin="round"
              className="lucide lucide-send"
            >
              <path d="m22 2-7 20-4-9-9-4Z" />
              <path d="M22 2 11 13" />
            </svg>
          </Button>
        </form>
      </div>
    </div>
  )
}






"use client"

import type React from "react"
import { useState, useRef, useEffect, useCallback, useMemo } from "react"
import { ArrowLeft, MoreVertical, Search, Phone, VideoIcon } from "lucide-react"
import { Button } from "@/components/ui/button"
import { Avatar } from "@/components/ui/avatar"
import { Input } from "@/components/ui/input"
import { Badge } from "@/components/ui/badge"
import { useMobile } from "@/hooks/use-mobile"
import MessageBubble from "@/components/chat/message-bubble"
import { getAllUserForSpecificChat, getChatMessages, sendChatMessage } from "@/actions/chat"
import { Chat } from "@/interface/interface"
import { useAuth } from "@/providers/auth-provider"
import { useSocket } from '@/hooks/use-socket';

interface ChatWindowProps {
  chatId: string | null
  onBackClick: () => void
  onProfileClick: () => void
  isChatLoading: boolean
  userChats: Chat[]
}

export default function ChatWindow({ 
  chatId, 
  onBackClick, 
  onProfileClick,
  isChatLoading,
  userChats
}: ChatWindowProps) {
  const [newMessage, setNewMessage] = useState("")
  const [chatMessages, setChatMessages] = useState<any[]>([])
  const [isMessagesLoading, setIsMessagesLoading] = useState(false)
  const messagesEndRef = useRef<HTMLDivElement>(null)
  const isMobile = useMobile()
  const { user } = useAuth()
  
  // Use the socket hook
  const { socket, isConnected, sendSocketMessage } = useSocket(chatId);
  
  // Find the selected chat from userChats
  const selectedChat = useMemo(() => {
    return userChats.find(chat => chat.id === chatId) || null
  }, [chatId, userChats])

  // Group messages by date - memoized to prevent recalculation on every render
  const messagesByDate = useMemo(() => {
    const groupedMessages: Record<string, any[]> = {}
    
    // Ensure chatMessages is an array before using forEach
    if (Array.isArray(chatMessages)) {
      chatMessages.forEach((message) => {
        if (message && message.sent_at) {
          const date = new Date(message.sent_at).toLocaleDateString()
          if (!groupedMessages[date]) {
            groupedMessages[date] = []
          }
          groupedMessages[date].push(message)
        }
      })
    }
    
    return groupedMessages
  }, [chatMessages])

  // Listen for new messages via socket
  useEffect(() => {
    if (!socket || !chatId) return;
    
    const handleNewMessage = (data: any) => {
      if (data.chatId === chatId) {
        // Add the new message to the chat
        setChatMessages(prevMessages => [...prevMessages, data.message]);
      }
    };
    
    socket.on('new-message', handleNewMessage);
    
    return () => {
      socket.off('new-message', handleNewMessage);
    };
  }, [socket, chatId]);

  const handleSendMessage = useCallback(async (e: React.FormEvent) => {
    e.preventDefault()
    if (!newMessage.trim() || !chatId) return

    try {
      // Send message to server
      const message = await sendChatMessage(chatId, newMessage)
      
      if (message) {
        // Emit the message via socket for real-time updates
        sendSocketMessage({
          id: message.id,
          chat_id: chatId,
          sender_id: user?.id,
          content: newMessage,
          type: 'text',
          sent_at: new Date().toISOString(),
          sender: {
            //@ts-ignore
            name: user?.name || 'You',
            //@ts-ignore
            avatar_url: user?.avatar_url
          }
        });
        
        // Clear the input
        setNewMessage("")
      }
    } catch (error) {
      console.error("Error sending message:", error)
    }
  }, [newMessage, chatId, user, sendSocketMessage])


  // Fetch messages when chatId changes
  useEffect(() => {
    const fetchMessages = async () => {
      if (!chatId) return
      
      setIsMessagesLoading(true)
      try {
        const messages = await getChatMessages(chatId)
        setChatMessages(Array.isArray(messages) ? messages : [])
      } catch (error) {
        console.error("Error fetching messages:", error)
        setChatMessages([]) 
      } finally {
        setIsMessagesLoading(false)
      }
    }
    
    fetchMessages()
  }, [chatId])



  
  // Scroll to bottom when messages change
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" })
  }, [chatMessages])

  if (isChatLoading || isMessagesLoading) {
    return (
      <div className="flex items-center justify-center h-full">
        <div className="animate-spin h-8 w-8 border-4 border-primary border-t-transparent rounded-full"></div>
      </div>
    )
  }

  if (!selectedChat) {
    return (
      <div className="flex items-center justify-center h-full bg-muted/20">
        <div className="text-center">
          <h2 className="text-xl font-semibold mb-2">Chat App</h2>
          <p className="text-muted-foreground">Select a chat to start messaging</p>
        </div>
      </div>
    )
  }

  return (
    <div className="flex flex-col h-full">
      {/* Chat Header */}
      <div className="flex items-center p-2 border-b bg-sidebar">
        {isMobile && (
          <Button variant="ghost" size="icon" className="mr-1" onClick={onBackClick}>
            <ArrowLeft className="h-5 w-5" />
          </Button>
        )}

        <div className="flex items-center flex-1 cursor-pointer" onClick={onProfileClick}>
          <Avatar className="h-10 w-10 mr-3">
            <img src={selectedChat.avatar || "/placeholder.svg?height=40&width=40"} alt={selectedChat.title} />
          </Avatar>

          <div>
            <h3 className="font-medium text-sm">{selectedChat.title}</h3>
            <p className="text-xs text-muted-foreground">
              {selectedChat.isGroup ? "Group Â· " : ""}
              {selectedChat.status || "online"}
            </p>
          </div>
        </div>

        <div className="flex items-center gap-1">
          <Button variant="ghost" size="icon" className="rounded-full">
            <VideoIcon className="h-5 w-5" />
          </Button>
          <Button variant="ghost" size="icon" className="rounded-full">
            <Phone className="h-5 w-5" />
          </Button>
          <Button variant="ghost" size="icon" className="rounded-full">
            <Search className="h-5 w-5" />
          </Button>
          <Button variant="ghost" size="icon" className="rounded-full">
            <MoreVertical className="h-5 w-5" />
          </Button>
        </div>
      </div>

      {/* Messages */}
      <div
        className="flex-1 overflow-y-auto p-4 space-y-4"
        style={{
          backgroundImage: "url('/placeholder.svg?height=500&width=500')",
          backgroundSize: "30%",
          backgroundRepeat: "repeat",
        }}
      >
        {Object.entries(messagesByDate).map(([date, dateMessages]) => (
          <div key={date} className="space-y-2">
            <div className="flex justify-center">
              <Badge variant="outline" className="bg-background/80 text-xs font-normal">
                {date}
              </Badge>
            </div>

            {dateMessages.map((message) => {
              // Check if the current user is the sender
              const isCurrentUserSender = user?.id === message.sender_id;
              
              return (
                <MessageBubble 
                  key={message.id} 
                  message={{
                    id: message.id,
                    senderId: message.sender_id,
                    senderName: message.sender.name,
                    senderAvatar: message.sender.avatar_url,
                    content: message.content,
                    time: new Date(message.sent_at).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}),
                    date: new Date(message.sent_at).toLocaleDateString(),
                    label: message.type !== "text" ? message.type : undefined
                  }} 
                  isOwn={isCurrentUserSender} 
                />
              );
            })}
          </div>
        ))}
        {(!chatMessages || chatMessages.length === 0) && (
          <div className="flex justify-center items-center h-full">
            <p className="text-muted-foreground">No messages yet</p>
          </div>
        )}
        <div ref={messagesEndRef} />
      </div>

      {/* Message Input */}
      <div className="p-2 border-t bg-sidebar">
        <form onSubmit={handleSendMessage} className="flex items-center gap-2">
          <Button type="button" variant="ghost" size="icon" className="rounded-full">
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="24"
              height="24"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              strokeWidth="2"
              strokeLinecap="round"
              strokeLinejoin="round"
              className="lucide lucide-smile"
            >
              <circle cx="12" cy="12" r="10" />
              <path d="M8 14s1.5 2 4 2 4-2 4-2" />
              <line x1="9" x2="9.01" y1="9" y2="9" />
              <line x1="15" x2="15.01" y1="9" y2="9" />
            </svg>
          </Button>
          <Button type="button" variant="ghost" size="icon" className="rounded-full">
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="24"
              height="24"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              strokeWidth="2"
              strokeLinecap="round"
              strokeLinejoin="round"
              className="lucide lucide-paperclip"
            >
              <path d="m21.44 11.05-9.19 9.19a6 6 0 0 1-8.49-8.49l8.57-8.57A4 4 0 1 1 18 8.84l-8.59 8.57a2 2 0 0 1-2.83-2.83l8.49-8.48" />
            </svg>
          </Button>

          <Input
            value={newMessage}
            onChange={(e) => setNewMessage(e.target.value)}
            placeholder="Type a message"
            className="rounded-full bg-background"
          />

          <Button type="submit" variant="ghost" size="icon" className="rounded-full">
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="24"
              height="24"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              strokeWidth="2"
              strokeLinecap="round"
              strokeLinejoin="round"
              className="lucide lucide-send"
            >
              <path d="m22 2-7 20-4-9-9-4Z" />
              <path d="M22 2 11 13" />
            </svg>
          </Button>
        </form>
      </div>
    </div>
  )
}




